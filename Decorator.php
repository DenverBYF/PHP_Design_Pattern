<?php


/**
 * Created by PhpStorm.
 * User: denverb
 * Date: 18/3/12
 * Time: 下午7:44
 */
/*
 * 装饰器模式是一种结构型模式,它动态的给一个对象添加一些额外的指责。就添加功能来说,装饰器模式比生成子类更加灵活,
 * 其以对客户透明的方式动态地给一个对象让添加更多的指责。装饰器模式可以在不使用创建更多子类的情况下,将对象的功能加以扩展。
 * 主要角色:
 * 		抽象构件角色:定义一个对象接口,以规范准备接受附加指责的对象,从而可以给这些对象动态地添加职责。
 * 		具体构件角色:定义一个将要接收附加职责的类。
 * 		装饰角色:持有一个指向抽象构件角色的指针,并定义一个与抽象构件接口一致的接口。
 * 		具体装饰角色:负责给构建对象增加附件的职责
 * */

//抽象构件角色
interface Component
{
	public function operation();
}

//具体构件角色
abstract class Decorator implements Component
{
	protected $_component;
	public function __construct(Component $component)
	{
		$this->_component = $component;
	}
	public function operation()
	{
		$this->_component->operation();
	}
}

//具体装饰类A
class ConcreteDecoratorA extends Decorator
{
	public function __construct(Component $component)
	{
		parent::__construct($component);
	}
	public function operation()
	{
		parent::operation(); // TODO: Change the autogenerated stub
		$this->addedOperationA();
	}
	public function addedOperationA() {}
}

//具体装饰类B
class ConcreteDecoratorB extends Decorator
{
	public function __construct(Component $component)
	{
		parent::__construct($component);
	}
	public function operation()
	{
		parent::operation(); // TODO: Change the autogenerated stub
		$this->addedOperationB();
	}
	public function addedOperationB() {}
}

//具体装饰角色
class ConcreteComponent implements Component
{
	public function operation()
	{
		// TODO: Implement operation() method.
	}
}

//client
$component = new ConcreteComponent();
$decoratorA = new ConcreteDecoratorA($component);
$decoratorB = new ConcreteDecoratorB($decoratorA);

$decoratorA->operation();
$decoratorB->operation();